#include <iostream>
#include <cassert>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <climits>

// class Solution {
// public:
//     int minPathPrice = INT_MAX;
//     void dfs(int pathPrice, int currLocation, int numStops, std::unordered_set<int>& visited, std::unordered_map<int, std::vector<std::pair<int, int>>>& adjList, int destination, int k) {
//         if (currLocation == destination) {
//             std::cout << "Path to destination found, cost is: " << pathPrice << "\n";
//             if (pathPrice < minPathPrice) {
//                 minPathPrice = pathPrice;
//                 return;
//             }
//         }
//         visited.insert(currLocation);
//         // Base case, we have arrived at destination or have exceeded max trip stops
//         if (numStops > k || pathPrice > minPathPrice) {
//             return;
//         } 


//         // Recursive case, we are not yet at destination, check next location(s)
//         for (int i = 0; i < adjList[currLocation].size(); ++i) {
//             int newPrice = pathPrice + adjList[currLocation][i].second;
//             int newLocation = adjList[currLocation][i].first;
//             if (visited.find(newLocation) != visited.end()) {
//                 continue;
//             } else {
//                 dfs(newPrice, newLocation, numStops + 1, visited, adjList, destination, k);
//             }
//         }
//         visited.erase(currLocation);
//     }

//     int findCheapestPrice(int n, std::vector<std::vector<int>> flights, int src, int dst, int k) {
//         std::unordered_set<int> visitedCities;
//         std::unordered_map<int, std::vector<std::pair<int, int>>> adjList;
//         // Fill adjList
//         for (auto& flight : flights) {
//             adjList[flight[0]].push_back({flight[1], flight[2]});
//         }
//         dfs(0, src, 0, visitedCities, adjList, dst, k);

//         std::cout << minPathPrice << "\n";
//         return (minPathPrice == INT_MAX) ? -1 : minPathPrice;
//     }
// };

/*
    Flights given in [a, b, price] where flight goes from a to b
    src = start position
    dst = destination position
    k = most num of stops acceptable

    return cheapest path from src to dst

    Graph problem, dfs with backtracking
    adjlist looks like -- currLocation -> destination, price
    0, 1, 100
    1, 2, 100
    1, 3, 600
    2, 3, 200
    2, 0, 100
    For each location, check adjacency list, add price to pathPrice, add destination to visited
        if next destination is in visited, return to prune path
        if pathPrice > minPathPrice, return to prune path
    Otherwise, call dfs on next node
*/

// Generated by ChatGPT, applied DP on top of DFS -- results in TLE
class Solution {
public:
    int dfs(int currLocation, int numStops, std::unordered_map<int, std::vector<std::pair<int, int>>>& adjList, int destination, int k, std::vector<std::vector<int>>& dp) {
        // Check if the destination is reached or if the number of stops is exceeded
        if (currLocation == destination) {
            return 0;
        }
        if (numStops == k + 1) {
            return INT_MAX;
        }

        // If the result is already computed, return it
        if (dp[currLocation][numStops] != INT_MAX) {
            return dp[currLocation][numStops];
        }

        int minPrice = INT_MAX;
        for (const auto& [nextLocation, price] : adjList[currLocation]) {
            int nextPrice = dfs(nextLocation, numStops + 1, adjList, destination, k, dp);
            if (nextPrice != INT_MAX) {
                minPrice = std::min(minPrice, price + nextPrice);
            }
        }

        // Update the DP array with the computed result
        dp[currLocation][numStops] = minPrice;
        return minPrice;
    }

    int findCheapestPrice(int n, std::vector<std::vector<int>> flights, int src, int dst, int k) {
        std::unordered_map<int, std::vector<std::pair<int, int>>> adjList;
        std::vector<std::vector<int>> dp(n, std::vector<int>(k + 2, INT_MAX));

        // Create adjacency list
        for (const auto& flight : flights) {
            adjList[flight[0]].emplace_back(flight[1], flight[2]);
        }

        // Start DFS with DP
        int result = dfs(src, 0, adjList, dst, k, dp);
        return (result == INT_MAX) ? -1 : result;
    }
};


int main() {
    Solution solution;
    
    assert(solution.findCheapestPrice(4, {{0,1,100},{1,2,100},{2,0,100},{1,3,600},{2,3,200}}, 0, 3, 1) == 700);
    assert(solution.findCheapestPrice(10, {{3,4,4},{2,5,6},{4,7,10},{9,6,5},{7,4,4},{6,2,10},{6,8,6},{7,9,4},{1,5,4},{1,0,4},{9,7,3},{7,0,5},{6,5,8},{1,7,6},{4,0,9},{5,9,1},{8,7,3},{1,2,6},{4,1,5},{5,2,4},{1,9,1},{7,8,10},{0,4,2},{7,2,8}}, 6, 0, 7) == 14);

    std::cout << "All tests passed!";
    return 0;
}